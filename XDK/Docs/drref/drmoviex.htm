<html><head><title>IMoaDrMovieContext</title></head><body bgcolor="#FFFFFF" link="#ff3300" alink="#ff3300" vlink="#333399"><A HREF = "../drdg/index.htm">DR Developer's Guide</A><BR><A HREF = "index.htm"> DR Interfaces</A> | <A HREF = "drmthndx.htm">DR Methods</A> | <A HREF = "drtypndx.htm">DR Types and Misc API</A><hr width=45% align=left><h2><font face=arial,helvetica,sans-serif><A name = "IMoaDrMovieContext">IMoaDrMovieContext</A></font></h2><hr width=45% align=left><BR>Interface ID: <CODE>IID_IMoaDrMovieContext</CODE><BR>Pointer type: <CODE>PIMoaDrMovieContext</CODE><BR>Inheritance: <CODE>IMoaUnknown</CODE><BR>Header file: <A HREF = "../../include/driservc.h">driservc.h</A><BR><DL><DT><h3><font face=arial,helvetica,sans-serif>Description</font></h3><DD><P>The <CODE>IMoaDrMovieContext</CODE> interface lets you set up the player's context so you can access the current movie. This interface is especially important in Windows if you create your own windows and receive messages directly from Windows. If the operating system calls your Xtra directly and you call the player, the player does not know what context you are executing in.<P>You do not need this interface if you do not have your own windows or use threads, or if you are coding for the Macintosh (the threading and windowing model of the Macintosh is simpler than that of Windows). However, this interface is available on both platforms--calling it unnecessarily is harmless.<P><B>Note:</B> <CODE>ImoaDrMovieContext</CODE> was introduced in Director 7 because of a change in behavior between Director 6 and Director 7. In Director 6, the player used global variables to keep track of the current movie, and Xtras could callback into the player at any time. However, in Director 7, the player uses stack contexts to track the current movie.<p>There are two issues that are inter-related:<OL><P><LI>In Internet Explorer, Director runs in Apartment Model. Under Apartment Model, each control instance will always be called on the same thread, but different instances may be called on different threads. And a window created by a thread will always have messages dispatched to it on that thread. So, if you display two copies of a page with a Shockwave movie using your Xtra, your Xtra is likely to be called on different threads.<p><LI>In Internet Explorer or Navigator on Windows, if you create your own windows, the operating system sends messages to your window without the player knowing. So when you call into the player, it does not know what movie the calls apply to. In Navigator, Director is always called on the same thread, so threading is not a problem. But not knowing what window a call applies to is a problem in both browsers.<p>In Internet Explorer, if you have your own window, the operating system sends you messages without the player having any opportunity to control multiple threads. Another movie in another window might be in the middle of a player operation when you get your message. If you call into the player while the other movie is in there, the player is likely to crash.</OL><p>If you do not have your own windows or background threads, this will notmatter. You will always get control by the player calling you, and it makessure that only one thread is executing in it at a time. So you might becalled on different threads, but you will never be executing your code on twothreads at the same time. When it calls you, the player also knows whatmovie the call applies to.<h4><font face=arial,helvetica,sans-serif>Pushing and popping contexts</font></h4><p>Whenever an Xtra might be calling the player back from a message sent directly to its window proc by Windows, the player calls must be bracketed with calls to <CODE>PushXtraContext()</CODE> and <CODE>PopXtraContext()</CODE>. The <CODE>DrContextState</CODE> must be a local variable in the calling function.<p>For example, <CODE>m_pIDrMovieContext</CODE> is a <CODE>PIDrMovieContext</CODE> member of the asset Xtra's object class:<pre>/* This code is sometimes called directly from a Windows event/  received by the Xtra's wndproc. */DrContextState drContextState;if (m_pObj->m_pIDrMovieContext &&    !(m_pObj->m_pIDrMovieContext->PushXtraContext(&drContextState))){    ... /* Call other Director interfaces at will */    m_pObj->m_pIDrMovieContext->PopXtraContext(&drContextState);}</pre><p>If the <CODE>PushXtraContext()</CODE> call is not made or the <CODE>PopXtraContext()</CODE> call is dropped, the player may crash or produce other unexpected results. These calls inform the player what movie context applies and, for the ActiveX control only, provide protection for multiple threads.<p>The Xtra needs to acquire an <CODE>IDrMovieContext</CODE> interface during a call from the player, for example, during the sprite asset's constructor.<p>Use a different instance of <CODE>IMoaDrMovieContext</CODE> for each instance of your Xtra class. The <CODE>IMoaDrMovieContext</CODE> includes which movie you are being used in, so if you try to share a single copy between multiple instances, you will get information about the wrong movie when you make calls to the player.<p>Use <CODE>IMoaDrPlayer</CODE> to get an <CODE>IMoaDrMovie</CODE> interface to the active movie. Then <CODE>QueryInterface</CODE> that interface to get an <CODE>IMoaDrMovieContext</CODE> interface. Release the <CODE>IMoaDrMovie</CODE> and <CODE>IMoaDrPlayer</CODE> interfaces (unless you need them for other reasons), and keep the <CODE>IMoaDrMovieContext</CODE> as a member of your asset Xtra object. The following C++ code snippet works:<pre>/* m_pIDrMovieContext is a new member of the asset pObj class */m_pIDrMovieContext = NULL;PIMoaDrPlayer pIMoaDrPlayer = NULL;PIMoaDrMovie pIMoaDrMovie = NULL;if (!m_pICallback->QueryInterface(&IID_IMoaDrPlayer,                                  (PPMoaVoid)&pIMoaDrPlayer)){    if (!pIMoaDrPlayer->GetActiveMovie(&pIMoaDrMovie))    {        pIMoaDrMovie->QueryInterface(&IID_IMoaDrMovieContext,                                     (PPMoaVoid)&m_pIDrMovieContext);        pIMoaDrMovie->Release();    }    pIMoaDrPlayer->Release();}</pre><p>The destructor must release, of course:<pre>if (m_pIDrMovieContext != NULL){    m_pIDrMovieContext->Release();    m_pIDrMovieContext = NULL;}</pre><h4><font face=arial,helvetica,sans-serif>Releasing and reacquiring threads</font></h4><p><CODE>ReleaseExclusiveThread()</CODE> and <CODE>ReacquireExclusiveThread()</CODE> should rarely be needed and are effective only in the ActiveX control. You might need them in a situation such as the following.<p>When a <CODE>GoToNetPage</CODE> is issued, Internet Explorer requires services that happen to be implemented on its main thread. There may be a Shockwave movie on that thread. The following scenario can cause a deadlock because the thread of window 2 is waiting for services from the thread of window 1 and vice versa:<OL><P><LI>Window 2 (running on a secondary thread) is executing player code.<LI>Window 1 (running on the main thread) blocks at entry to the player.<LI>Window 2 issues a <CODE>GoToNetPage</CODE>, which calls Internet Explorer services.<LI>Internet Explorer services send a message to the main thread and wait for a response.</OL><p>If you encounter this type of situation in the ActiveX control only, use <CODE>ReleaseExclusiveThread()</CODE> to give up the player, make the system call that needs to run on the main thread, then call <CODE>ReacquireExclusiveThread()</CODE>. You <I>must</I> reacquire after you release -- there are counted resources in there, and if you return to a caller who calls <CODE>PopXtraContext()</CODE>, the system will crash.<p>Of the Xtras written for Director by Macromedia, only the Flash asset and ActiveX control asset needed thread protection, and only the <CODE>GoToNetPage</CODE> operation needed to release and reacquire the thread.<h4><font face=arial,helvetica,sans-serif>Xtras with background threads</font></h4><P>On Windows, you must not call the player from threads you create, unless you are running within the ActiveX control.<P>The Director 7 ActiveX control includes thread protection, because of the use of Apartment Model. So, if you are in the control, you can use <CODE>IMoaDrMovieContext::PushXtraContext()</CODE> and <CODE>PopXtraContext()</CODE> to call the player from a background thread. Use the code described earlier for handling messages sent directly from Windows to your Xtra.<P>None of the other environments--Authoring, Projectors, Netscape Plugin, or ShockMachine--include thread reentrancy protection. The player must always be called on the main thread.<P>If you have a background thread, you can handle this by using <CODE>SendMessage()</CODE> to switch to the primary thread for player calls:<P><OL><LI>On the primary thread (for example, in your Xtra class's constructor), create a window, hWnd. Dispose of the window in the destructor.<P><LI>Attach a window proc to the window.<P><LI>Structure your code so that it contains a procedure or function with the logic you need to call from the background thread, including <CODE>PushXtraContext()</CODE> and <CODE>PopXtraContext()</CODE> calls. Package the parameters to the function so that they can be sent through the window proc. The arguments can be a DWORD and a WORD, returning a DWORD. The DWORDs might be pointers to structures.<P><LI>Define a windows user message code, such as WM_BACKGROUND_TO_PRIMARY.<P><LI>In the wndproc, handle WM_BACKGROUND_TO_PRIMARY by calling your proc from step 3, passing lParam and wParam, and returning the result.<P><LI>On the background thread, instead of calling the proc from step 3, call SendMessage(hWnd, ...) to send the message to window created in step 1.</OL><P>Windows will switch to the thread that created the window, execute the message on that thread, and resume the background thread only when the message has been processed and the result is returned from the wndproc.<P>A couple of notes:<P><UL><LI>Deadlock: If the primary thread is blocked waiting for the background thread to release a semaphore, exit a critical section, or the like, <CODE>SendMessage()</CODE> will not wake it up. <CODE>SendMessage()</CODE> will never return. (If the primary thread sent a message to the secondary, the message will be processed. The primary thread will see it as a recursive call. This does not cause problems, as the player is always ready to process messages when it does a <CODE>SendMessage()</CODE>.)<P><LI>Messages received during <CODE>SendMessage()</CODE> from your background thread will not return until primary-thread wndproc returns. If <CODE>SendMessage()</CODE> is used to send a message to a window created by your background thread, your background thread wnd proc will be called recursively from <CODE>SendMessage()</CODE>.</UL><h4><font face=arial,helvetica,sans-serif>Use caution with threads and windows</font></h4><p>Code carefully to <I>never</I> pop without a push or vice-versa. If you use exceptions, make sure your catch pops if it needs to. Never release without reacquiring. Protect your global variables and any other data that is shared between instances with push/pop to make sure multiple threads do not find their way into the same code at the same time. Test your Xtra in several movies at the same time in Internet Explorer/Windows, and stress all the instances at the same time. That should uncover any lingering code that needs to be protected.</DL><DL><DT><h3><font face=arial,helvetica,sans-serif>Methods</font></h3><DD><!MethodListBegin><DD><A HREF = "#PushXtraContext">PushXtraContext()</A><BR><A HREF = "#PopXtraContext">PopXtraContext()</A><BR><A HREF = "#ReleaseExclusiveThread">ReleaseExclusiveThread()</A><BR><A HREF = "#ReacquireExclusiveThread">ReacquireExclusiveThread()</A><!MethodListEnd></DL><!------------------------------------------------> <hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A name = "PopXtraContext">PopXtraContext()</A></font></h3><DL><DT><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DD><DL><CODE><DT>PopXtraContext(PIMoaDrMovieContext <I>This</I>, <BR>   <DD>PDrContextState <I>pDrContextState</I>)</CODE></DL><BR></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DD><DL><DT><CODE><I>This</I></CODE><DD>Pointer to the <CODE>IMoaNotificationClient</CODE> interface<BR><BR><DT><CODE><I>pDrContextState</I></CODE><DD><CODE>PDrContextState</CODE>&nbsp;&nbsp;Address of the <CODE>DrContextState</CODE> local variable that was provided to <CODE><A HREF = "#PushXtraContext">PushXtraContext()</A></CODE><BR><BR></DL></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DD><CODE>MoaError</CODE></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DD>This method leaves the context established by <CODE>PushXtraContext()</CODE>.</DL><BR><!------------------------------------------------> <hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A name = "PushXtraContext">PushXtraContext()</A></font></h3><DL><DT><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DD><DL><CODE><DT>PushXtraContext(PIMoaDrMovieContext <I>This</I>, <BR>   <DD>PDrContextState <I>pDrContextState</I>)</CODE></DL><BR></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DD><DL><DT><CODE><I>This</I></CODE><DD>Pointer to the <CODE>IMoaNotificationClient</CODE> interface<BR><BR><DT><CODE><I>pDrContextState</I></CODE><DD><CODE>PDrContextState</CODE>&nbsp;&nbsp;Address of a <CODE>DrContextState</CODE> that is a local variable in the calling procedure<BR><BR></DL></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DD><CODE>MoaError</CODE></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DD>This method establishes a movie context for subsequent calls to the player. In the ActiveX control, this method also blocks multiple threads from simultaneous execution. <CODE><I>pDrContextState</I></CODE> must be a local variable in the calling function. Before returning to its caller, that function must leave the established context by calling <CODE><A HREF = "#PopXtraContext">PopXtraContext()</A></CODE> with the same <CODE><I>pDrContextState</I></CODE>.</DL><BR><!------------------------------------------------> <hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A name = "ReacquireExclusiveThread">ReacquireExclusiveThread()</A></font></h3><DL><DT><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DD><DL><CODE><DT>ReacquireExclusiveThread(PIMoaDrMovieContext <I>This</I>, <BR>   <DD>PDrContextState <I>pDrContextState</I>)</CODE></DL><BR></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DD><DL><DT><CODE><I>This</I></CODE><DD>Pointer to the <CODE>IMoaNotificationClient</CODE> interface<BR><BR><DT><CODE><I>pDrContextState</I></CODE><DD><CODE>PDrContextState</CODE>&nbsp;&nbsp;Address of the <CODE>DrContextState</CODE> local variable that was provided to <CODE><A HREF = "#ReacquireExclusiveThread">ReacquireExclusiveThread()</A></CODE><BR><BR></DL></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DD><CODE>MoaError</CODE></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DD>This method reacquires the context released by <CODE><A HREF = "#ReleaseExclusiveThread">ReleaseExclusiveThread()</A></CODE>. This method is rarely used.</DL><BR><!------------------------------------------------> <hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A name = "ReleaseExclusiveThread">ReleaseExclusiveThread()</A></font></h3><DL><DT><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DD><DL><CODE><DT>ReleaseExclusiveThread(PIMoaDrMovieContext <I>This</I>, <BR>   <DD>PDrContextState <I>pDrContextState</I>)</CODE></DL><BR></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DD><DL><DT><CODE><I>This</I></CODE><DD>Pointer to the <CODE>IMoaNotificationClient</CODE> interface<BR><BR><DT><CODE><I>pDrContextState</I></CODE><DD><CODE>PDrContextState</CODE>&nbsp;&nbsp;Address of a <CODE>DrContextState</CODE> that is a local variable in the calling procedure<BR><BR></DL></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DD><CODE>MoaError</CODE></DL><DL><DT><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DD>In the ActiveX control only, this method releases the player so it can be called from other threads. This method must be followed by a <CODE><A HREF = "#ReacquireExclusiveThread">ReacquireExclusiveThread()</A></CODE> call using the same <CODE><I>pDrContextState</I></CODE>. <CODE><I>pDrContextState</I></CODE> must be the address of a local variable in the calling function. This method is rarely used.</DL><BR><hr width=45% align=left><BR><A HREF = "../copyrite.htm"> Copyright(c) 1995, 1996, 1997, 1998, 1999 Macromedia, Inc.</A> <p></P></body></html>