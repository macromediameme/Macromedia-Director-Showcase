<HTML><HEAD><TITLE>Implementing MOA Xtras</TITLE></HEAD><body bgcolor="#FFFFFF"  link="#ff3300" alink="#ff3300" vlink="#333399"><A HREF="index.htm">MOA Developer's Guide</A><BR><A HREF="../moref/index.htm" >MOA Interfaces</A> | <A HREF="../moref/momthndx.htm" >MOA Methods</A>| <A HREF="../moref/motypndx.htm" >MOA Types and Misc API</A><HR width=45% align=left><H3><A NAME="RTFToC2"><FONT SIZE=4 face=arial,helvetica,sans-serif>Director 7 Xtra Development Kit: MOA Developer's Guide</FONT></A></H3><H2><FONT SIZE=5 face=arial,helvetica,sans-serif>Implementing MOA Xtras</FONT></H2><HR width=45% align=left><DL><DT><h3><font face=arial,helvetica,sans-serif>Introduction</A> </font></h3><P><DD>This chapter describes coding details for implementing MOA Xtras.<P>The first part describes how to code a MOA Xtra. It presents acomplete coding example of an Xtra implementing the hypotheticalXtra interface, <TT>IMoaHello.</TT> This discussion includes detailsabout how to code Xtras in both C and C++. The second sectiondiscusses some standard calling conventions used in implementingMOA Xtras. The final part provides a synopsis of the MOA standardinterfaces. <DT><h3><font face=arial,helvetica,sans-serif><A NAME="RTFToC4">Implementing a MOA Xtra</A> </font></h3><P><DD>In general, there are three things you do to implement Xtras.First, you identify the interfaces to use--both the Xtra interfacesto implement and the callback interfaces to call in the application.Next, you define a class, specifying its name, instance variables,and the Xtra interfaces it implements. Finally, you write implementationsfor each method in those interfaces. Identifying an interfaceand defining a class both require MOA identifiers, which are discussedfirst. The sections that follow describe how to actually codeMOA objects. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC5">MOA identifiers</A> </font></h4><P>For a provider and user to agree on an interface, they need acommon way to identify it. MOA uses MOA identifiers (type <TT>MoaID</TT>),an implementation detail shared with COM (which refers to themas globally unique identifiers or GUIDs). In addition to uniqueinterface identifiers, MOA uses unique identifiers for each class.The class identifier provides a hook for an application to accessyour Xtra implementation. <P>MOA identifiers are large (128 bit) values unique to each interfaceand class. MOA identifiers are assigned to globals shared by theproviders and users of an interface. <P>Your Xtra code uses MOA identifiers in several ways:<UL><LI>Define a unique <TT>MoaID </TT>for any interface you definein your code<LI>Define a unique <TT>MoaID </TT>for each class you define inyour code<LI>Acquire the previously defined <TT>MoaID </TT>for each interfaceyou implement in a class<LI>Acquire the <TT>MoaID</TT> for any classes you explicitlyinstantiate in your code<LI>Acquire a <TT>MoaID</TT> for any interfaces your method implementationswill need to use </UL><P>The various uses of MOA identifiers are discussed in the sectionsthat follow. To define a <TT>MoaID</TT> for an interface or class,you use a standard utility program. On the Macintosh, the programGenUID.app is provided with the MOA XDK for this purpose; on Windows,use the Microsoft utility GUIDGEN.EXE, which is provided withthe Visual C++ compiler. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC6">Acquiring an interface</A> </font></h4><P>In implementing an Xtra, both the Xtra interfaces you provideand the callback interfaces you use are defined by Macromedia.Thus, Xtras can be programmed entirely without defining interfacesof their own. In some cases, you may choose to define a MOA interfaceto represent behavior shared by your objects but not specifiedby Macromedia. In any case, understanding how an interface isdefined will help you understand how to implement a class.<P>Each interface has a distinct <TT>MoaID</TT>--referred to as theinterface identifier or IID--used to acquire instances of theinterface. Each interface has a name, used to represent the specifictype of the interface. An interface also includes the names, parameters,and return types for its methods. The following example showsthese details, looking at the definition of a simple interface--<TT>IMoaHello</TT>--withjust one method, <TT>Hello()</TT>. <P>Note that in MOA, as in COM, all interfaces are typed using aname with the prefix <TT>I</TT>. Interface types are used to identifyan interface when it is specified as a parameter of a functionor method, or as the type of a variable.<P>The following code demonstrates the minimal definition of a simpleinterface, <TT>IMoaHello</TT>. This code would appear in a .hfile, for example moahello.h:<PRE>#include &quot;moaxtra.h&quot;#define INTERFACE IMoaHelloDEFINE_GUID(IID_IMoaHello, 0xAC3590A6L, 0x0062, 0xE623, 0x00, 0x00, 		0x08, 0x00, 0x07, 0x57, 0xFC, 0x90);DECLARE_INTERFACE_(IMoaHello, IMoaUnknown){        STD_IUNKNOWN_METHODS        STDMETHOD(Hello) (THIS_ PIMoaStream pStream) PURE;};</PRE><P>To understand what this definition does, take a closer look at the code, line by line:	  <P><TT>#include &quot;moaxtra.h&quot; </TT><BR><TT>#define INTERFACE</TT><P>The first line of code includes the standard header for definingMOA Xtras. The file moaxtra.h provides a set of macros used todefine MOA interfaces and classes, and contains the IIDs for somestandard MOA interfaces. The second line defines a macro, INTERFACE,which must be defined for the macros used in the subsequent declarations.The lines following this preamble provide the actual interfacedeclaration. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC7">Declaring the interface identifier</A></font></h5><P>To declare the interface identifier, you create a unique 128-bitvalue and identify it to MOA, using the <TT>DEFINE_GUID</TT> macro.Interface identifiers are assigned to global variables, whosename is the name of the interface with the prefix <TT>IID_</TT>.This is demonstrated for <TT>IMoaHello</TT> in the following code:<PRE>DEFINE_GUID(IID_IMoaHello, 0xAC3590A6L, 0x0062, 0xE623, 0x00, 0x00, 		0x08, 0x00, 0x07, 0x57, 0xFC, 0x90);</PRE><P>This identifier must be defined with the same value in every modulethat implements or uses this interface. For interfaces definedby MOA or an application, interface identifiers are provided bythe standard header files provided with the Xtra Development Kit.For interfaces you define yourself, you use a utility programto generate a unique <TT>MoaID</TT>. On the Macintosh, the programGenUID.app is provided with the MOA XDK for this purpose; on Windows,use the Microsoft utility GUIDGEN.EXE, which is provided withthe Visual C++ compiler. <P>Users of this interface use the interface identifier, in thiscase <TT>IID_IMoaHello</TT>, to request the interface from a provider.Users of your Xtra objects similarly use interface identifiersto request the interfaces you implement. MOA provides a standardtechnique for requesting interfaces from objects, through the<TT>QueryInterface()</TT> method inherited by all MOA interfaces.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC8">Declaring interface methods</A></font></h5><P>As described earlier, an interface is a set of methods, or functionprototypes, for a complete, specific behavior. The heart of aninterface definition is its method declarations. <P>In the case of <TT>IMoaHello</TT>, the interface has just onemethod, <TT>Hello()</TT>. Every class that implements <TT>IMoaHello</TT>will provide its own implementation of this method. Here is thecode declaring the <TT>IMoaHello</TT> interface:<PRE>DECLARE_INTERFACE_(IMoaHello, IMoaUnknown){        STD_IUNKNOWN_METHODS        STDMETHOD_(void, Hello) (THIS_ PIMoaStream pStream) PURE;};</PRE><P>In the first line, the <TT>DECLARE_INTERFACE_</TT> macro describesthe name of the interface and the interface it inherits from.Inheritance in this case simply means that the first interface,<TT>IMoaHello</TT>, includes the methods defined in the secondinterface, <TT>IMoaUnknown</TT>. All MOA interfaces inherit from<TT>IMoaUnknown</TT>, which provides the standard method QueryInterface()for requesting interfaces from an object. <P>Note that some object models such as C++ provide for one classto inherit from another, thus allowing implementations to be inherited.In MOA, as in COM, there is no inheritance of implementations.Inheritance is limited to the abstract behavior defined by aninterface. (However, MOA provides a default implementation ofthe methods defined by <TT>IMoaUnknown</TT>.) <P>In the second line, the <TT>STD_IUNKNOWN_METHODS</TT> macro declaresthe default MOA implementation of the <TT>IMoaUnknown</TT> interface.This is required to complete the inheritance specified for <TT>IMoaHello</TT>.<P>In the third line, the <TT>STDMETHOD_</TT> macro is used to declarethe sole method in the <TT>IMoaHello</TT> interface. Within theparentheses of the macro itself, the return type and name of themethod <TT>(void, Hello)</TT> are declared. The next parenthesescontain the type and parameter of any arguments to the method.There are two arguments to the <TT>Hello</TT> method, <TT>THIS</TT>and <TT>pStream</TT>. <TT>THIS</TT> is always the first argumentto a method, and represents the interface itself. The meaningof <TT>THIS</TT> is described in greater detail in &quot;Writingmethod implementations&quot; later in this section. The <TT>pStream</TT>parameter represents a pointer to an instance of the <TT>IMoaStream</TT>interface. This parameter provides the application's interfaceto the stream used to write the Xtra's greeting. <P><B>Note:</B> In declaring a MOA interface, all method parametersmust be exactly 4 bytes in length. Parameters smaller than this(e.g., chars, Booleans) must be expanded into an explicit 4-byteparameter. Parameters larger than this must be passed by pointer.There is one exception: type MoaDouble (8-byte floating point)may always be passed by value.<P>Note that the macro <TT>PURE</TT> is provided for compatibilitywith C++. This macro is described in the section &quot;ImplementingXtras in C++,&quot; later in this chapter. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC9">Defining a class</A> </font></h4><P>To provide a specific Xtra interface, your Xtra defines a classthat implements that interface. To define a class, you providea <TT>MoaID</TT>--referred to as the class identifier or <TT>CLSID</TT>--forthat class, similar to the interface identifier. You then specifythe instance variables, private data available within the methodimplementations of your class. You also specify interfaces implementedby the class. Finally, you specify method implementations foreach method in each interface provided by the class.<P>Here's the code defining a simple class, the <TT>World</TT> class,that implements just one interface, the <TT>IMoaHello</TT> interface.<PRE>#include &quot;moahello.h&quot;DEFINE_GUID(CLSID_World, 0xAC3593FFL, 0x0063, 0xAF65,0x00, 0x00, 0x08, 0x00, 0x07, 0x57, 0xFC, 0x90);EXTERN_BEGIN_DEFINE_CLASS_INSTANCE_VARS( World )        char * greeting; EXTERN_END_DEFINE_CLASS_INSTANCE_VARSEXTERN_BEGIN_DEFINE_CLASS_INTERFACE( World, IMoaHello)        EXTERN_DEFINE_METHOD( void, Hello, (THIS_ PIMoaStream pStream))EXTERN_END_DEFINE_CLASS_INTERFACEEXTERN_BEGIN_DEFINE_CLASS_INTERFACE( World, IMoaRegister)        EXTERN_DEFINE_METHOD( void, Hello, (THIS_ PIMoaCache pCache, PIMoaDict pDict) EXTERN_END_DEFINE_CLASS_INTERFACE</PRE><P>The first line includes the previously defined interface <TT>IMoaHello</TT>,contained in the file moahello.h. The following discussions describethe significant details of this code sample. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC10">Defining the class identifier</A></font></h5><P>Each class has a unique identifier, which is defined in exactlythe same way you define an interface identifier. The only distinctionis that the global name is given the prefix <TT>CLSID</TT>. <PRE>DEFINE_GUID(CLSID_World, 0xAC3593FFL, 0x0063, 0xAF65, 0x00,0x00, 0x08, 0x00, 0x07, 0x57, 0xFC, 0x90); </PRE><P>As with interface identifiers, class identifiers must be distinctfrom the identifiers of any interfaces or classes. Unique classidentifier values are created using a utility application. Onthe Macintosh, the program GenUID.app is provided with the MOAXDK for this purpose; on Windows, use the Microsoft utility GUIDGEN.EXE,which is provided with the Visual C++ compiler.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC11">Declaring instance variables</A></font></h5><P>The instance variables represent private data that is allocatedfor each instance of the class. The <TT>World</TT> class has asingle instance variable, <TT>greeting</TT>, intended to containa string used by an object to greet its users. This instance variableis declared as follows:<PRE>EXTERN_BEGIN_DEFINE_CLASS_INSTANCE_VARS( World )        PMoaChar greeting; EXTERN_END_DEFINE_CLASS_INSTANCE_VARS</PRE><P>The <TT>greeting</TT> instance variable can be accessed only withinthe method implementations of the <TT>World</TT> class. Use ofthe <TT>greeting</TT> instance variable is demonstrated in thediscussion &quot;Writing method implementations&quot; later inthis section. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC12">Declaring interface methods</A></font></h5><PRE>EXTERN_BEGIN_DEFINE_CLASS_INTERFACE(World, IMoaHello )EXTERN_DEFINE_METHOD( void, Hello, (THIS_ PIMoaStream pStream) )EXTERN_END_DEFINE_CLASS_INTERFACE</PRE><P>The final set of macros in this code declares the single methodof the <TT>IMoaHello</TT> interface and identifies it with the<TT>World</TT> class.<P>The Xtra code includes a similar declaration for each interfaceimplemented by a class. As in this example, all Xtras should provideat least one class that implements the <TT>IMoaRegister</TT> interface.This interface is implemented in a way that's specific to thetype of functionality being implemented by the Xtra. For example,Transition Xtras implement <TT>IMoaRegister</TT> in one way, SoundEditXtras implement <TT>IMoaRegister</TT> in another. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC13">Writing method implementations</A> </font></h4><P>A method implementation represents a class's specific code fora method in an interface. The method implementation is associatedwith a method through the virtual function table, which is setup in the same source file as the method implementations. Writingmethod implementations is the bulk of the work in implementingXtras. This section looks at a simple example of a method implementation.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC14">Implementing the World class</A></font></h5><P>The following code sample is a complete implementation of the<TT>World</TT> class: <PRE>#define INITGUID 1 /*at least one file defines this macro*/#include &quot;worldcls.h&quot; /* MoaID and globals for class*/BEGIN_DEFINE_CLASS_INTERFACE( World, IMoaHello )        DEFINE_METHOD( Hello, World_Hello )END_DEFINE_CLASS_INTERFACEBEGIN_DEFINE_CLASS_INTERFACE( World, IMoaRegister )        DEFINE_METHOD( Register, World_Register )END_DEFINE_CLASS_INTERFACEBEGIN_XTRA        BEGIN_XTRA_DEFINES_CLASS( World, 1 )                CLASS_DEFINES_INTERFACE( World, IMoaHello, 1 )                CLASS_DEFINES_INTERFACE( World, IMoaRegister, 1 )        END_XTRA_DEFINES_CLASSEND_XTRA/* class creator and destructor */STDMETHODIMP_(MoaError) MoaCreate_World(World FAR * This &gt; {X_ENTER        char    *theString = &quot;Hello, world&quot;        long    theSize = strlen(theString) + 1        if (This-&gt;greeting = \                This-&gt;pCalloc-&gt;lpVtbl-&gt;NRAlloc(This-&gt;pCalloc, theSize))        {                strcpy(This-&gt;greeting, theString);                X_RETURN( MoaError, kMoaErr_NoErr );         }        X_RETURN( MoaError, kMoaErr_OutOfMem );X_EXIT}STDMETHODIMP_(void) MoaDestroy_World(World FAR * This) {X_ENTER        if (This-&gt;greeting)        {                This-&gt;pCalloc-&gt;lpVtbl-&gt; NRFree(This-&gt;pCalloc, This-&gt;greeting);         }        X_RETURN_VOID; X_EXIT}/* interface creator and destructor functions */STDMETHODIMP_(MoaError) MoaCreate_World_IMoaHello(World_IMoaHello* This) {X_ENTER        X_RETURN( MoaError, kMoaErr_NoErr );X_EXIT}STDMETHODIMP_(void) MoaDestroy_World_IMoaHello(World_IMoaHello* This){X_ENTER        X_RETURN_VOID;X_EXIT}/*implement IMoaRegister creator and destructor here*//* interface method implementation */STDMETHODIMP_(MoaError) World_Hello (World_IMoaHello FAR * This,PIMoaStream pStream){X_ENTERpStream-&gt;lpVtbl-&gt;write(pStream, this-&gt;pObj-&gt;greeting, strlen(this-&gt;pObj-&gt;greeting) + 1, NULL);        X_RETURN( MoaError, kMoaErr_NoErr );X_EXIT}STDMETHODIMP_(MoaError) World_Register (World_IMoaRegister FAR * This,PIMoaCache pCache, PIMoaDict pDict)(/* see description of Register() implementation */}</PRE><P>While <TT>World</TT> implements only two interfaces, each witha single method, this sample demonstrates that a complete implementationrequires some additional code.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC15">Setting up virtual function tables</A></font></h5><P>A class implements an interface by defining a function for eachmethod, the method implementation. Each method implementationhas a name distinct from its actual method name. In this example,the method implementation for the <TT>Hello</TT> method is named<TT>World_Hello</TT>. The virtual function table is an internalMOA structure that records the relationship between methods andimplementations. The tables for <TT>IMoaHello</TT> and <TT>IMoaRegister</TT>are set up at the beginning of the file, with the code for<TT>World</TT>'s <TT>IMoaHello</TT> function table as follows:<TT>BEGIN_DEFINE_CLASS_INTERFACE( World, IMoaHello )</TT> <TT>DEFINE_METHOD(Hello, World_Hello )</TT> <TT>END_DEFINE_CLASS_INTERFACE</TT><h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC16">Declaring implemented interfaces</A></font></h5><P>Next, the class declares all the interfaces it implements. Inthis case, the <TT>World</TT> class implements both <TT>IMoaHello</TT>and <TT>IMoaRegister</TT>. The following block specifies this:<PRE>BEGIN_XTRA        BEGIN_XTRA_DEFINES_CLASS( World, 1 )                 CLASS_DEFINES_INTERFACE( World, IMoaHello, 1 )                CLASS_DEFINES_INTERFACE( World, IMoaRegister, 1 )        END_XTRA_DEFINES_CLASSEND_XTRA</PRE><P>The <TT>BEGIN_XTRA_DEFINES_CLASS</TT> macro specifies the nameof the class being defined and the version number. Xtra developersare responsible for tracking and incrementing class version numberswith new releases of their Xtras. When MOA finds multiple versionsof the same class among its Xtras, it selects the one with thehighest version number to instantiate. The <TT>CLASS_DEFINES_INTERFACE</TT>macro specifies an interface being implemented. The Xtra developeralso supplies a version number for each interface of a class,and MOA similarly selects the interface with the highest versionnumber to instantiate. <P>Since the World class implements two interfaces, each is listedusing the <TT>CLASS_DEFINES_INTERFACE</TT> macro. If the Xtraimplemented more than one class, each would be declared in thisblock using the <TT>BEGIN_XTRA_DEFINES_CLASS</TT> and <TT>END_XTRA_DEFINES_CLASS</TT>macros.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC17">Creator and destructor functions</A></font></h5><P>For each Xtra, an application needs the ability to create newinstances of its classes, and to acquire interfaces to those instances.Applications also need to manage the presence of external coderesources--such as Xtras--in their allocated memory space, andto purge those resources when they are no longer in use. The creatorand destructor functions provide the mechanism. <P>Class creator and destructor functions are similar in severalways. The creator initializes the object by allocating memory,acquiring handles to interfaces, and assigning values to instancevariables; the destructor deallocates memory and disposes of handles.The names of the two functions are formed using standard prefixes(<TT>MoaCreate_</TT> or <TT>MoaDestroy_</TT>) and the class name.<P>You never call a creator or destructor function directly. The<TT>IMoaCallback</TT> method <TT>MoaCreateInstance()</TT> is providedto create instances of specific classes; this method in turnscalls the creator function after the instance has been allocated.An allocated object stays in memory as long as there are referencesto any of its interfaces. When all interface handles for the objecthave been dropped, MOA can call the destructor function to purgeit from memory.<P>Note that creator and destructor functions don't implement methodsin an interface. Instead, they provide standard entry points toyour Xtra for use by MOA. <P><TT>World</TT>'s creator function, <TT>MoaCreate_World()</TT>,allocates memory for a greeting string, then assigns the addressof the string to the <TT>greeting</TT> instance variable:<PRE>STDMETHODIMP_(MoaError) MoaCreate_World(World FAR * This){X_ENTER        char    *theString = &quot;Hello, world&quot;        long    theSize = strlen(theString) + 1        if (This-&gt;greeting = \                This-&gt;pCalloc-&gt;lpVtbl-&gt;NRAlloc(This-&gt;pCalloc, theSize))        {                strcpy(This-&gt;greeting, theString);                X_RETURN( MoaError, kMoaErr_NoErr );        }        X_RETURN_VOID;X_EXIT}</PRE><P>This code allocates memory for the greeting string using a standardMOA interface, IMoaCalloc. The pointer <TT>pCalloc</TT> refersto this interface, while <TT>NRAlloc()</TT> is a method in thisinterface. Xtras always use memory allocation provided by an applicationthrough this interface and another, handle-based allocation interface,<TT>IMoaHandle</TT>.<P>The <TT>World</TT> class's destructor function, <TT>MOADestroy_World()</TT>,is implemented to deallocate the string allocated in the creator:<PRE>STDMETHODIMP_(void) MoaDestroy_World(World FAR * This){X_ENTER        if (This-&gt;greeting)        {                This-&gt;pCalloc-&gt;lpVtbl-&gt; \                        NRFree(This-&gt;pCalloc, This-&gt;greeting);        }        X_RETURN_VOID;X_EXIT}</PRE><P>Again, the IMoaCalloc interface is used to free the memory itpreviously allocated. <P>In addition to an object's instance variables, memory needs tobe allocated for each interface of an object. The virtual functiontable requires memory, provided automatically by MOA. MOA alsodefines some standard instance variables for interfaces, suchas <TT>pObj</TT>, a pointer to the object providing the interface.<P>The interface creator and destructor functions are implementedin much the same ways as the corresponding functions for the class.The example above shows the creator and destructor for IMoaHello;similar code would be used for the IMoaRegister interface. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC18">Implementing the Hello() method</A></font></h5><P>World's <TT>Hello()</TT> method implementation, <TT>World_Hello()</TT>,is very straightforward, highlighting several MOA coding conventions.<PRE>STDMETHODIMP_(MoaError) World_Hello (World_IMoaHello FAR * This,PIMoaStream pStream){X_ENTER        pStream-&gt;lpVtbl-&gt;write(pStream,                                This-&gt;pObj-&gt;greeting,                                strlen(This-&gt;pObj-&gt;greeting) + 1,                               NULL);        X_RETURN( MoaError, kMoaErr_NoErr );X_EXIT}</PRE><P>First, the macro STDMETHODIMP_ is used to identify the implementationand declare its return type. Following the function name, theparameters are listed in standard C-language declarations. Thefirst parameter to C-language method implementation is a pointerto the interface itself, referred to by <TT>This</TT>. (A C++implementation differs slightly with regard to this argument.See &quot;Implementing Xtras in C++,&quot; the next section inthis document, for more information.) <P>In the implementation of <TT>IMoaHello</TT>, the first parameteris a far pointer to an instance of the <TT>IMoaHello</TT> interface.Note that the type of <TT>This</TT>, <TT>World_IMoaHello</TT>,is a subtype of the interface itself. <TT>This</TT> must be typedin this way in order to provide access to the instance variablesdeclared in its class. The second parameter is a pointer to aninstance of the IMoaStream interface. When the application callsan the <TT>Hello()</TT> method, it passes in a stream where thegreeting can be written. <P>The code for writing the string calls the <TT>write()</TT> methodin the <TT>IMoaStream</TT> interface. To call <TT>write()</TT>,the code goes through <TT>pStream</TT>'s <TT>lpVtbl</TT> instancevariable, representing the stream object's virtual function table.To access its own greeting instance variable, the code uses thereference <TT>This-&gt;pObj-&gt;greeting</TT>. <TT>pObj</TT> providesaccess to an object from an interface, which in turn providesaccess to the instance variables of the object. <P>Note that this code assumes all characters are written to thestream. To determine how many characters were actually written,the method call would pass a pointer to a MoaStreamCount ratherthan NULL as the last argument. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC19">Implementing the Register() method</A></font></h5><P>In addition to implementing a specific Xtra interface, at leastone class in each Xtra must implement the <TT>IMoaRegister</TT>interface. This interface is called by an application the firsttime it detects your Xtra in one of the standard Xtra folders.Its purpose is to add information about your Xtra to the applicationcache, from which the application gets information about the Xtrasit has available. <P>The <TT>IMoaRegister</TT> interface consists of one method, <TT>Register()</TT>.In implementing this method, your Xtra must provide the IDs ofclasses that provide interfaces of interest to the application.Each MOA application specifies which interfaces it needs to register.The declaration of the Xtra interface should include a specificationof keys that Xtras need to add to the cache. For example, theearlier declaration of the <TT>IMoaHello</TT> interface mighthave included a definition of a key such as <TT>key_IMoaHello_Menu</TT>that would specify the name of the menu entry to associate withyour Xtra, such as:<PRE>/* registry entry */#define key_IMoaHello_Menu &quot;key_IMoaHello_Menu&quot; /*  * all implementations of IMoaHello should use this key to * register a C string to display in the menu  */</PRE><P>In addition to specifying the interfaces of interest to it, aMOA application may specify other registry entries for its Xtras,such as menu items or other data. See the documentation for aparticular Xtra interface for any such entries and the correspondingkey definitions. In addition to the information required by MOAand a specific interface, you may cache your own information touse in initializing your Xtra, or at any time during the lifeof your Xtra. <P>Caching capabilities to support these requirements are providedthrough several interfaces, including the callback interfacesIMoaCache and <TT>IMoaDict</TT>, and the Xtra interfaces <TT>IMoaRegister</TT>and <TT>IMoaInitFromDict</TT>. <P>The following example shows <TT>World</TT>'s implementation of<TT>IMoaRegister</TT>. It uses <TT>IMoaCache</TT> and <TT>IMoaDict</TT>to register the class and interface IDs of the World Xtra. Italso registers an item with the key <TT>key_IMoaHello_Menu</TT>to be displayed by the application. <PRE>STDMETHODIMP_(MoaError) StdHelloWorld_IMoaRegister_Register(        StdHelloWorld_IMoaRegister FAR * This,         PIMoaCache pCache,         PIMoaXtraEntryDict pXtraDict){X_ENTER        MoaError err;        PIMoaRegistryEntryDict pRegDict;/*  * standard for all Xtras: * register classes and interfaces provided */        err = pCache-&gt;lpVtbl-&gt;AddRegistryEntry(pCache,                pXtraDict,                &amp;CLSID_World,                &amp;IID_IMoaHello,                &amp;pRegDict );        if (err) X_RETURN(MoaError, err);/*  * specific to IMoaHello interface: * specify a menu entry using the defined key */        err = pRegDict-&gt;lpVtbl-&gt;Put(pRegDict,                 kMoaDictType_CString,                &quot;World&quot;,                0,                 key_IMoaHello_Menu);        if (err) X_RETURN(MoaError, err);        X_STD_RETURN(kMoaErr_NoErr);X_EXIT}</PRE><h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC20">Providing Resources</A> </font></h4><P>In addition to the code for your Xtra, on the Macintosh you'llalso need to add some magic resources to your Xtra.<P>All Macintosh Xtras must have an MXcf resource. The Rez definition of this type lookslike so:<PRE>type 'MXcf' {        longint = $$CountOf(memberArray);        wide array memberArray {                literal longint archType,                kPowerPC = 'pwpc', k68kCodeResource = 'cr68';                longint offset, kZeroOffset = 0;                longint length, kWholeFork = 0;        };};</PRE><P>You'll typically include an MXcf that includes both a &quot;cr68&quot;and &quot;pwpc&quot; entry:<PRE>resource 'MXcf' (128) {        {                kPowerPC, kZeroOffset, kWholeFork,                k68kCodeResource, kZeroOffset, kWholeFork        }};</PRE><P>Note that you don't need to add an icon resource for your Xtra;MOA applications automatically provide the appropriate icon forall Xtras. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC21">Implementing Xtras in C++</A> </font></h4><P>MOA is written in C for compatibility on platforms that offeronly C-language compilers. However, in creating Xtras for particularplatforms, the developer may choose to use either C or C++. Theprevious example demonstrated conventions for coding Xtras inC. <P>C++ provides a useful programming model for implementing MOA objects.The main differences between coding Xtras with C and C++ is inthe way interfaces are declared and implemented. This sectionexplores these differences.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC22">Declaring an interface in C++</A></font></h5><P>In C++, a MOA interface is declared as an abstract class. Themethods in an interface are declared as pure virtual functions.The MOA macros for declaring interfaces provide the implementationautomatically when you specify C++ as your coding model. Lookagain at how the <TT>IMoaHello</TT> interface is declared:<PRE>DECLARE_INTERFACE_(IMoaHello, IMoaUnknown){        STD_IUNKNOWN_METHODS        STDMETHOD (Hello) (THIS) PURE;};</PRE><P>The first macro of interest, DECLARE_INTERFACE_, evaluates inC++ as: <PRE>struct FAR IMoaHello: public IMoaUnknown</PRE><P>This provides a standard C++ declaration for the interface IMoaHello,declaring it as a class that inherits from the class <TT>IMoaUnknown</TT>.<P>The second macro of interest, <TT>PURE</TT>, evaluates as <TT>=0</TT> in C++ (it evaluates to a null string in C). This representsthe C++ initializer for a pure virtual function. Pure virtualfunctions are member functions with no implementation in the classbeing declared. A class that declares only pure virtual functionsis an abstract class. Thus the interface is declared as an abstractC++ class. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC23">Implementing an interface in C++</A></font></h5><P>A MOA class implements an interface using a C++ class. The implementingC++ class inherits from the abstract class of the interface. Ineffect, a MOA object in C++ is a collection of C++ objects, eachrepresenting an interface of the object. <P>The name of the implementing C++ class takes a standard form,combining the MOA class name and the interface name. For example,the name of the C++ class for <TT>World</TT>'s implementationof the <TT>IMoaHello</TT> interface is <TT>World_IMoaHello</TT>.<P>The method implementations for a MOA interface are C++ memberfunctions. The names of the method implementations conform tostandard C++ naming conventions. For example, world's implementationof the <TT>Hello</TT> method takes the name <TT>World_IMoaHello::Hello</TT>.<P>In C++, the local variable <TT>this</TT> is provided implicitlywithin a method implementation. Thus, there is no need explicitlydeclare <TT>this</TT> as a function parameter. However, this implementationdetail doesn't apply to the MOA class creator and destructor functions,which are standard C functions, coded exactly as in the previousexample. <P>Note that <TT>this</TT> (with a lowercase `t') is a C++ keywordand is used rather than <TT>This</TT> within a C++ method implementation.<TT>This </TT>(with a lowercase `T') is used in C-language MOAcode, including the class creators and destructors, to avoid conflictwith <TT>this</TT> when compiled with a C++ compiler. <P>Here's a source file that implements the <TT>World</TT> classand its <TT>IMoaHello</TT> interface using C++:<PRE>#define INITGUID 1 /*at least one file defines this macro*/#define CPLUS#include &quot;worldcls.h&quot; /* MoaID and globals for class*/BEGIN_DEFINE_CLASS_INTERFACE( World, IMoaRegister )        DEFINE_METHOD( Register, World_IMoaRegister::Register )END_DEFINE_CLASS_INTERFACEBEGIN_DEFINE_CLASS_INTERFACE( World, IMoaHello )        DEFINE_METHOD( Hello, World_IMoaHello::Hello )END_DEFINE_CLASS_INTERFACEBEGIN_XTRA        BEGIN_XTRA_DEFINES_CLASS( World, 1)                CLASS_DEFINES_INTERFACE( World, IMoaHello, 1 )                CLASS_DEFINES_INTERFACE( World, IMoaRegister, 1 )        END_XTRA_DEFINES_CLASSEND_XTRA/* class creator and destructor *//* note that This is passed as the first parameter *//* in the MOA class creator and destructor functions, *//* This is a MOA object, not an interface */STDMETHODIMP_(MoaError) MoaCreate_World(World FAR * This){X_ENTER        char    *theString = &quot;Hello, world&quot;        long    theSize = strlen(theString) + 1        if (This-&gt;greeting = This-&gt;pCalloc-&gt;NRAlloc(theSize))        {                strcpy(This-&gt;greeting, theString);                X_RETURN( MoaError, kMoaErr_NoErr );        }        X_RETURN( MoaError, kMoaErr_OutOfMem );X_EXIT}STDMETHODIMP_(void) MoaDestroy_World(World FAR * This){X_ENTER        if (This-&gt;greeting)        {                This-&gt;pCalloc-&gt;NRFree(This-&gt;greeting);        }        X_RETURN_VOID;X_EXIT}/* C++ interface creator and destructor *//* note that these function names follow C++ conventions *//* for class creator and destructors */ /* also note this is not passed as first parameter */World_IMoaHello::World_IMoaHello (MoaError FAR * pErr){X_ENTER        *pErr = kMoaErr_NoErr;X_EXIT}World_IMoaHello::~World_IMoaHello (void){X_ENTER        X_RETURN_VOID;X_EXIT}/* creators and destructors for IMoaRegister go here *//* method implementation *//* note that function name follows C++ conventions *//* and that this is not passed as the first parameter */STDMETHODIMP_(MoaError) World_IMoaHello::Hello (PIMoaStream pStream) {X_ENTER        /* Calling from C++: no need to go through lpVtbl or pass &quot;this&quot; */        pStream-&gt;Write(strlen(this-&gt;pObj-&gt;greeting) + 1, NULL);        X_RETURN( MoaError, kMoaErr_NoErr );X_EXIT}/* implement World_IMoaRegister::Register() here */</PRE><DT><h3><font face=arial,helvetica,sans-serif><A NAME="RTFToC24">Implementing well-behaved Xtras</A> </font></h3><P><DD>In writing an Xtra, it's important to remember thatyour code may not always be invoked by a particular Macromediaapplication. Xtras are potentially clients of all Macromedia applications.This means that they may be called by applications that providedifferent callback interfaces than described in a particular XDK.It's your responsibility to ensure that you interact appropriately,whatever the host application, and that you handle all errorsraised in your Xtra code. </FONT><h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC25">Error check method calls</A> </font></h4><P>The standard return for MOA methods is a <TT>MoaError</TT> value.You should take advantage of this feature and error test callsto MOA methods. This is particuarly important in calling the <TT>IMoaUnknown::QueryInterface()</TT>method provided by all interfaces. If you request an interfacethat an object doesn't provide, you'll get the error <TT>kMoaErr_BadInterface</TT>.If your Xtra ignores this return value and calls a method in therequested interface, your Xtra may cause MOA and the host applicationto fail. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC26">Bullet proof your registration class</A></font></h4><P>One critical section of Xtra code is the creator function forthe class providing your Xtra's <TT>IMoaRegister</TT> interface.This code is invoked by every MOA application that finds yourXtra. Every MOA-capable Macromedia application registers everyXtra in the general Macromedia/Xtras directory, regardless ofits type. Thus, you must write your the class creator functionin a way that doesn't depend on a specific application or setof callback interfaces. In general, be sure to perform error checkingwhen using any interfaces provided by the host application. Oneway to avoid trouble in this section of code is to create a separateclass specifically to provide the <TT>IMoaRegister</TT>interface.This avoids initializing instance variables for the Xtra at registrationtime. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC27">Write re-entrant code</A> </font></h4><P>Xtras should be written to be re-entrant. Specifically, you shouldavoid the use of global variables. If you use static variablesin function implementations, be sure to include a &quot;lock&quot;variable that is set when a caller enters the code and reset uponexit. This ensures that two processes won't attempt to accessthe same code and alter the same static variables simultaneously.<DT><h3><font face=arial,helvetica,sans-serif><A NAME="RTFToC28">MOA standard API</A> </font></h3><P><DD>This section details some of the API used in programming withMOA. MOA defines a small set of calling conventions and a handfulof standard interfaces that can be used in coding Xtras for anyMacromedia application. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC29">MOA calling conventions</A> </font></h4><P>The World examples demonstrate a very simple implementation ofa MOA Xtra. When coding method implementations for a MOA Xtra,you frequently use the following four basic operations for accessingMOA API: <UL><LI>Call a method in an interface<LI>Access one interface from another<LI>Access an object from an interface implementation<LI>Access instance variables from an object </UL><P>The calling conventions for these operations are described inthe following sections. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC30">Calling a method in an interface</A></font></h5><P>In MOA objects, methods are organized in a virtual function tablebelonging to the interface, referenced through the <TT>lpVtbl</TT>instance variable of all interfaces. To access this structure,assuming <TT>pInterface</TT> is the pointer to a MOA interface,use the following form: <PRE>pInterface-&gt;lpVtbl </PRE><P><TT>To call a specific method in an interface, you reference themethod through the virtual function table. For example, the followingrepresents a method call for the oneArgMethod</TT> of the interface<TT>pInterface</TT>:<PRE>pInterface-&gt;lpVtbl-&gt;oneArgMethod(pInterface)</PRE><P><TT>In this example, the oneArgMethod</TT> has just one argument.In MOA, the first argument to a method is the interface to whichthe method belongs, and is represented by the parameter <TT>This</TT>.(Note that you don't need to know whether the particular implementationof an interface is coded in C or C++; you can always supply theinterface as the first parameter to a method.) Returning to theearlier example, you could access a <TT>World</TT> object's <TT>Hello</TT>method through a pointer to the <TT>IMoaHello</TT> interface.In the following code fragment, a local variable <TT>pHello</TT>provides such a pointer:<PRE>pHello-&gt;lpVtbl-&gt;Hello(pHello)</PRE><P>The interface pointer is used both to reference the method andas the first argument to the method. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC31">Requesting one interface from another</A></font></h5><P>All MOA interfaces inherit the <TT>QueryInterface()</TT> methodof the <TT>IMoaUnknown</TT> interface, and MOA provides a standardimplementation of this method to all classes. This method is usedto request any interface belonging to an object. <P>Take the case of an object that provides two hypothetical interfaces,<TT>IMoaReason</TT> and <TT>IMoaEmotion</TT>. In the followingexample, <TT>pReason</TT> is an existing pointer to the object's<TT>IMoaReason</TT> interface. <TT>IID_IMoaEmotion</TT> is the<TT>MoaID</TT> of the <TT>IMoaEmotion</TT> interface. <TT>pEmotion</TT>is a freshly allocated pointer of type <TT>IMoaEmotion</TT>. Thiscode fragment calls <TT>QueryInterface()</TT> on the <TT>IMoaReason</TT>interface to get a pointer to the <TT>IMoaEmotion</TT>:<PRE>pReason-&gt;lpVtbl-&gt;QueryInterface(pReason, IID_IMoaEmotion, pEmotion) </PRE><P>When the call returns, <TT>pEmotion</TT> has a pointer to theobject's <TT>IMoaEmotion</TT> interface. <P>You can use the <TT>QueryInterface()</TT> method to get accessto interfaces provided by the callback object. The <TT>QueryInterface()</TT>method uses the interface identifier (described earlier) to specifythe interface being requested. <P>After you have finished using a particular interface, you explicitlyrelease it, using the <TT>Release()</TT> method. Like <TT>QueryInterface()</TT>,<TT>Release()</TT> is also inherited from <TT>IMoaUnknown</TT>.<PRE>pInterface-&gt;lpVtbl-&gt;Release(pInterface)</PRE><P>Calling <TT>Release()</TT> on an interface drops the referenceto it. MOA provides the application with ways to purge an objectwhen there are no longer any references to any of its interfaces.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC32">Accessing an object from a method implementation</A></font></h5><P>All MOA method implementations are passed a parameter, <TT>This</TT>,providing a pointer to the interface they belong to. (This isprovided explicitly in C; the corresponding this is provided implicitlyin C++). All interfaces, in turn, have a pointer to the MOA objectthey belong to, represented by the pObj member of the interfacestructure. To access an object within a method implementation,use the following reference: <PRE>This-&gt;pObj // in plain Cthis-&gt;pObj // in C++</PRE><P>You only access an object directly from within the implementationof a method in a class. Since interfaces are the fundamental unitsof behavior in MOA, interaction with other objects is performedsolely through the interfaces provided by those objects. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC33">Accessing instance variables from an object</A></font></h5><P>The instance variables defined by a class are private to its instances.To access an instance variable within the implementation of amethod, you go through the object. Thus, to access a variablenamed <TT>myVariable, use the following reference: </TT><PRE>This-&gt;pObj-&gt;myVariable // in plain C this-&gt;pObj-&gt;myVariable // in C++ </PRE><P>If you define instance variables for your Xtra object, you usethis calling convention to access them. For example, to accessWorld's greeting instance variable, the <TT>World</TT> class usesthe following code: <PRE>This-&gt;pObj-&gt;greeting // in plain Cthis-&gt;pObj-&gt;greeting // in C++</PRE><h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC34">MOA instance variables</A> </font></h4><P>All MOA objects are provided with certain instance variables automatically.Variables of interest to the MOA Xtra programmer are:<TT> </TT><DL><DT><TT>pCallback</TT> <DD><TT>IMoaCallback</TT> interface provided by callback object<DT><TT>pCalloc</TT> <DD><TT>IMoaCalloc</TT> interface provided by calloc object <DT><TT>pClassID</TT> <DD>Pointer to object's class identifier (<TT>CLSID</TT>) </DL><P>The interfaces provided by the <TT>pCallback</TT> and <TT>pCalloc</TT>instance variables are described in the next section. <h4><font face=arial,helvetica,sans-serif><A NAME="RTFToC35">MOA interfaces</A> </font></h4><P>Every MOA application implements several standard callback interfacesprovided for use by your Xtra. These interfaces provide accessto the application, representing MOA and system services throughplatform-independent API<DL><DT><TT>IMoaCallback</TT> <DD>General purpose MOA interface <DT><TT>IMoaCalloc</TT> <DD>Fixed memory allocation interface <DT><TT>IMoaHandle</TT> <DD>Relocatable memory allocation interface <DT><TT>IMoaCache</TT> <DD>Provides the application's registry of Xtras <DT><TT>IMoaDict</TT> <DD>Provides individual entries within the application's registry<DT><TT>IMoaStream</TT> <DD>Provides access to memory or file buffers (optional) <DT><TT>IMoaProgressBox</TT> <DD>Report progress of data processing from callback object (optional)</DL><P>The <TT>IMoaCallback</TT> and <TT>IMoaCalloc</TT> interfaces areautomatically supplied through the standard instance variables<TT>pCallback</TT> and <TT>pCalloc</TT>. To access the <TT>IMoaHandle</TT>interface of an application, you call the <TT>QueryInterface</TT>method on the <TT>pCallback</TT> instance variable. <P>The following demonstrates a complete call of <TT>QueryInterface</TT>to get access to the <TT>IMoaHandle </TT>interface: <TT>PIMoaCallback</TT><PRE>pCallback = This-&gt;pObj-&gt;pCallback; PIMoaHandle pHandle; err = pCallback-&gt;lpVtbl-&gt;QueryInterface(pCallback, IID_IMoaHandle, (PPMoaVoid)&amp;pHandle); /* check for errors| *//* use pHandle */ pHandle-&gt;lpVtbtl-&gt;Release(pHandle); </PRE><P>In this example, the callback object's <TT>IMoaCallback</TT> interfaceis queried for access to the <TT>IMoaHandle</TT> interface. Thelocation of the <TT>IMoaHandle</TT> interface is assigned to thepreviously declared variable <TT>pHandle</TT>. You can then use<TT>pHandle</TT> to call methods in the <TT>IMoaHandle</TT> interface.The following discussions summarize methods provided by each ofthe standard MOA interfaces.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC36">IMoaCache interface</A></font></h5><P>Every application provides the <TT>IMoaCache</TT> interface toits Xtras. This interface provides methods for caching registrationinformation about the Xtra. An application's <TT>IMoaCache</TT>interface is provided to an Xtra through its implementation ofthe <TT>IMoaRegister</TT> and <TT>IMoaInitFromCache </TT>interfaces.You may get the application cache at any time by calling the method<TT>MoaGetCache()</TT> on an object's <TT>pCallback</TT> instancevariable. <DL><DT><TT>AddRegistryEntry() </TT><DD>Adds new interface entry to cache <DT><TT>CreateNewInstanceFromRegistry()</TT><DD>Creates new instance <DT><TT>EnumerateFileEntries()</TT> <DD>Lists dictionaries for files <DT><TT>EnumerateRegistryEntries() </TT><DD>Lists dictionaries for specific interfaces <DT><TT>EnumerateRegistryEntriesFromFile()</TT><DD><TT>Lists all registry entries for a file </TT><DT><TT>EnumerateXtraEntries</TT> <TT>()</TT> <DD>Lists dictionaries for Xtras <DT><TT>GetFileSpecFromFileDict()</TT> <DD>Lists file specs for all files <DT><TT>GetInstanceFromRegistry() </TT><DD>Creates or retrieves single instance <DT><TT>SetXtraEntryNoncacheable() </TT><DD>Prevents Xtra from being cached<BR></DL><h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC37">IMoaCallback interface</A></font></h5><P>The callback object provides the <TT>IMoaCallback</TT> interfaceto your Xtra. This interface provides several methods for interactingwith MOA classes, and for accessing and releasing the resourcesbelonging to your Xtra. <DL><DT><TT>MoaCreateInstance()</TT><DD>Create instance of specified class and interface<DT><TT>MoaGetCache()</TT><DD>Get the IMoaCache interface <DT><TT>MoaBeginUsingResources()</TT><DD>Returns a reference to the Xtra's resource file <DT><TT>MoaEndUsingResources()</TT><DD>Deletes reference to the Xtra's resource file </DL><P>All MOA objects have a <TT>pCallback</TT> instance variable torefer to this interface. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC38">IMoaCalloc interface</A></font></h5><P>The calloc object provides the <TT>IMoaCalloc</TT> interface toyour Xtra. This interface provides a pair of methods for allocatingnon-relocatable memory: <DL><DT><TT>NRAlloc()</TT><DD>Allocate memory for use by the Xtra <DT><TT>NRFree()</TT> <DD>Free memory allocated with NRAlloc</DL><P>All MOA objects have a <TT>pCalloc</TT> instance variable to referto this interface. This instance variable is set when the objectis first instantiated. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC39">IMoaDict interface</A></font></h5><P>Every application provides implementations of the <TT>IMoaDict</TT>interface to its Xtras. This interface provides methods for registeringand accessing the capabilities of your Xtra. The <TT>IMoaDict</TT>interface is provided to you through your implementation of the<TT>IMoaRegister</TT> and <TT>IMoaInitFromCache</TT> interfaces.You may get specific dictionaries at any time by calling methodsof the IMoaCache interface.<DL><DT><TT>Count</TT><DD><TT>()</TT> Returns the number of entries in a dictionary<DT><TT>FindKey()</TT> <DD>Returns the value for a specified key <DT><TT>Get()</TT><DD>Gets an entry from a dictionary <DT><TT>GetInfo()</TT> <DD>Returns information about a dictionary entry <DT><TT>GetNth()</TT> <DD>Gets the specified entry in a dictionary <DT><TT>MakeDict()</TT> <DD>Makes a new dictionary belonging to the current dictionary<DT><TT>Put()</TT><DD>Puts an entry in a dictionary <DT><TT>Remove()</TT> <DD>Removes an entry from a dictionary <DT><TT>SetSize()</TT> <DD>Sets the size of the dictionary</DL><P>For more on the API of this interface, see chapter 3, &quot;MOAAPI Reference.&quot;<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC40">IMoaHandle interface</A></font></h5><P>The callback object provides the <TT>IMoaHandle</TT> interfaceto your Xtra. This interface provides a number of methods forallocating relocatable memory: <DL><DT><TT>Alloc</TT><DD><TT>()</TT> Allocate relocatable memory block <DT><TT>Free()</TT><DD>Free previously allocated handle <DT><TT>GetLargestFreeBlock() </TT><DD>Optionally implemented to return free space available <DT><TT>GetSize()</TT><DD>Return logical size of handle <DT><TT>Lock()</TT> <DD>Lock handle and return starting address pointer <DT><TT>Resize()</TT> <DD>Attempt to resize previously allocated handle <DT><TT>Unlock()</TT> <DD>Unlock handle <DT><TT>ZeroAlloc()</TT><DD>Allocate zeroed-out relocatable memory block </DL><P>This interface is a standard MOA interface, provided by all Xtra-capableapplications. To access this interface, you call <TT>QueryInterface</TT>on the <TT>pCallback</TT> instance variable of any MOA object.<h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC41">IMoaInitFromDict interface</A></font></h5><P>Your Xtra may optionally provide the <TT>IMoaInitFromDict</TT>interface to a MOA application. This standard interface providesone method for retrieving information from the application's registrationdictionary when objects are initialized. Each Xtra determineswhether or not to implement this interface and what type of informationto retrieve from the registration dictionary on initialization.Information retrieved from the dictionary by this interface mustbe placed there through the <TT>IMoaRegister</TT> interface. <DL><DT><TT>InitFromDict()</TT> <DD>Initialize an object using registry information </DL><P>Implementations of the <TT>IMoaInitFromDict</TT> interface usethe <TT>IMoaCache</TT> and <TT>IMoaDict</TT> interfaces providedthrough the <TT>InitFromDict()</TT> method. The <TT>IMoaInitFromDict</TT>interface is an optional MOA interface that may be provided byany Xtra. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC42">IMoaProgressBox interface</A></font></h5><P>The callback object optionally provides the <TT>IMoaProgressBox</TT>interface to your Xtra. This standard interface providesmethods for interacting with the user to report progress whilean Xtra processes data. <DL><DT><TT>OpenProgress()</TT><DD>Display progress dialog box <DT><TT>SetCaption</TT> <TT>()</TT><DD>Set caption displayed by progress dialog box <DT><TT>SetUserMessage()</TT><DD>Set message to user while dialog box is displayed <DT><TT>SetProgress()</TT><DD>Set completion value displayed by progress bar<DT><TT>TestUserCanceled()</TT><DD>Test for user clicking Cancel button <DT><TT>CloseProgress()</TT><DD>Hide progress dialog box </DL><h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC43">IMoaRegister interface</A></font></h5><P>Your Xtra provides the <TT>IMoaRegister</TT> interface to a MOAapplication. This standard interface provides one method for describingthe capabilities of the Xtra to the application. Each applicationdefines specific information to be supplied by the Xtra as itis registered. <DL><DT><TT>Register()</TT><DD>Registers capabilities of Xtra </DL><P>Implementations of the <TT>IMoaRegister</TT> interface use the<TT>IMoaCache</TT> and <TT>IMoaDict</TT> interfaces provided bythe application. The <TT>IMoaRegister</TT> interface is a standardMOA interface, provided by all Xtras. <h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC44">IMoaStream interface</A></font></h5><P>Certain MOA applications provide the <TT>IMoaStream</TT> interfaceto enable Xtra objects to archive and retrieve data. This interfaceis designed to be independent of the storage media, and thus equallyuseful for accessing data through disk files, memory buffers,network sockets, and other mechanisms. It is useful in applicationsthat generate output files containing a mixture of internal andXtra objects, such as movies created by Director. This interfacedefines several methods for reading and writing data<DL><DT><TT>Open()</TT> <DD>Opens the stream <DT><TT>Close()</TT> <DD>Closes the stream<DT><TT>Read()</TT> <DD>Reads data from the stream<DT><TT>ReadAhead()</TT> <DD>Reads data from the stream without seeking<DT><TT>Write()</TT> <DD>Writes data to the stream<DT><TT>GetPosition()</TT> <DD>Gets the current position in the stream <DT><TT>SetPosition()</TT> <DD>Sets the current position in the stream<DT><TT>GetEnd()</TT> <DD>Gets the size of the stream<DT><TT>Flush()</TT> <DD>Flushes the stream<DT><TT>GetModes()</TT> <DD>Gets the read/write modes of the stream</DL><h5><font face=arial,helvetica,sans-serif><A NAME="RTFToC45">IMoaUnknown interface</A></font></h5><P>All MOA objects provide the base interface <TT>IMoaUnknown</TT>.This is the interface you use to request other interfaces an objectprovides and to dispose of interfaces when you're done with them.The <TT>IMoaUnknown</TT> interface is inherited by all other interfacesimplemented in MOA. It consists of three methods of interest:<DL><DT><TT>QueryInterface()</TT> <DD>Query an object for a particular interface<DT><TT>AddRef()</TT> <DD>Increment the reference count for an interface <DT><TT>Release() </TT><DD>Decrement the reference count for an interface </DL><P>This interface is standard in MOA as in COM. The MOA macros providea default implementation of the methods in this interface. </DL><hr width=45% align=left><A HREF = "../copyrite.htm">Copyright &#169; 1995, 1996, 1997, 1998, 1999 Macromedia, Inc.</A></P></BODY><!--#include virtual="/uber/html/footer.html" --></html>