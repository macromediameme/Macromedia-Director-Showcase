<HTML><HEAD><TITLE>IMoaCache</TITLE></HEAD><body bgcolor="#FFFFFF"  link="#ff3300" alink="#ff3300" vlink="#333399"><A HREF="../moadg/index.htm">MOA Developer's Guide</A><BR><A HREF="index.htm">MOA Interfaces</A> | <A HREF="momthndx.htm">MOA Methods</A> | <A HREF="motypndx.htm">MOA Types and Misc API</A><hr width=45% align=left><h2><font face=arial,helvetica,sans-serif>IMoaCache</font></h2><hr width=45% align=left><P>Interface ID: <CODE>IID_IMoaCache<BR></CODE>Pointer type: <CODE>PIMoaCache<BR></CODE>Inheritance: <A HREF = "unknown.htm"><FONT SIZE=2>IMoaUnknown</FONT></A><BR>Header file: <A HREF = "../../include/moastdif.h">moastdif.h</A><BR><h3><font face=arial,helvetica,sans-serif>Description</font></h3><DL><DT><DD><BR>The IMoaCache interface is provided by all MOA applications foruse in registering an Xtra. Xtras register themselves by implementingthe Xtra interface <TT><FONT SIZE=2 FACE="Courier">IMoaRegister</FONT></TT>.They can initialize themselves from cached information by implementingthe <TT><FONT SIZE=2 FACE="Courier">IMoaInitFromDict</FONT></TT>interface. To get access to the cache at other times, you callthe <TT><FONT SIZE=2 FACE="Courier">MoaGetCache()</FONT></TT>method of the <TT><FONT SIZE=2 FACE="Courier">IMoaCallback</FONT></TT>interface. The <TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>interface is used to get and set individual entries in a cache.<BR><BR>An application's cache contains nested dictionaries of informationabout files contained in its Xtras folders, both the application-specificXtras folder and the system-wide Xtras folder. The dictionariesin the cache form a nested hierarchy. <BR><BR>At the top level, the cache contains a dictionary for each filefound in the Xtras folders. Cached files include all files foundin the Xtras folders, both those that contain Xtras and thosethat don't. This enables an application to cache non-MOA extensionfiles. <BR><BR>Within each file dictionary, there may be zero, one, or more Xtradictionaries. A file dictionary will contain no Xtra dictionaryif the file isn't an Xtras file. When a cached file contains Xtras,the file dictionary contains one Xtra dictionary for each Xtra.<BR><BR>Within each Xtra dictionary, the cache contains one registry dictionaryper class/interface that an application registers. If a givenXtra contains three classes, each implementing an interface ofinterest to an application, its Xtra dictionary will contain threeregistry dictionaries. <BR><BR>The methods of <TT><FONT SIZE=2 FACE="Courier">IMoaCache</FONT></TT>provide mechanisms for registering classes and interfaces andfor accessing the various dictionaries in a cache. The <TT><FONT SIZE=2 FACE="Courier">AddRegistryEntry()</FONT></TT>method is the main method used in an Xtra's <TT><FONT SIZE=2 FACE="Courier">IMoaRegister</FONT></TT>implementation to register its classes and interfaces. This methodreturns a pointer to a specific registry dictionary, which canbe used to store other information about an Xtra class and itsinterface. Other methods can be used to access file dictionaries,Xtra dictionaries, and registry dictionaries. To manipulate theentries in a dictionary, you use methods of the <TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>interface. <BR><BR></DL><P><h3><font face=arial,helvetica,sans-serif>Methods</font></h3><DL><DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Counting entries </font></h4><DL><DT><DD><A HREF = "#EnumerateFileEntries">EnumerateFileEntries()</A><BR><A HREF = "#EnumerateXtraEntries">EnumerateXtraEntries()</A> <BR><A HREF = "#EnumerateRegistryEntries">EnumerateRegistryEntries()</A><BR><A HREF = "#SetXtraEntryNoncacheable">SetXtraEntryNoncacheable()</A></DL><h4><font face=arial,helvetica,sans-serif>Modifying entries </font></h4><DL><DT><DD><A HREF = "#AddRegistryEntry">AddRegistryEntry()</A> </DL><h4><font face=arial,helvetica,sans-serif>Creating an instance </font></h4><DL><DT><DD><A HREF = "#GetInstanceFromRegistry">GetInstanceFromRegistry()</A><BR><A HREF = "#CreateNewInstanceFromRegistry">CreateNewInstanceFromRegistry()</A></DL><h4><font face=arial,helvetica,sans-serif>Accessing entries </font></h4><DL><DT><DD><A HREF = "#EnumerateRegistryEntriesFromFile">EnumerateRegistryEntriesFromFile()</A><BR><A HREF = "#GetFileSpecFromFileDict">GetFileSpecFromFileDict()</A></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="AddRegistryEntry">AddRegistryEntry()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>AddRegistryEntry(PIMoaCache<I>This</I>, <DD><BR>PIMoaXtraEntryDict<I>pXtraDict</I>, <BR>ConstPMoaClassID<I>pClassID</I>, <BR>ConstPMoaInterfaceID<I>pInterfaceID</I>, <BR>PIMoaRegistryEntryDict FAR *<I>ppRegistryDict</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pXtraDict</FONT></I></CODE><DD><CODE>PIMoaXtraEntryDict</CODE><TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>instance for the Xtra dictionary <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pClassID</FONT></I></CODE><DD><CODE>ConstPMoaClassID</CODE>CLSID of the class being registered<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></I></CODE><DD><CODE>ConstPMoaInterfaceID</CODE>IID of the interface beingregistered <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">ppRegistryDict</FONT></I></CODE><DD><CODE>PIMoaRegistryEntryDict FAR *</CODE><TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>instance for the registry dictionary <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR>Call this method inside your Xtra's implementation of the <TT><FONT SIZE=2 FACE="Courier">Register()</FONT></TT>method to add a registry entry to the cache. Pass the instanceof <TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT> passedto you by <TT><FONT SIZE=2 FACE="Courier">Register()</FONT></TT>asthe <TT><I><FONT SIZE=2 FACE="Courier">pXtraDict</FONT></I></TT>argument. The class and interface passed to this method are typically(but not necessarily) implemented within the same Xtra as the<TT><FONT SIZE=2 FACE="Courier">Register()</FONT></TT> method.<BR><BR>The argument for <TT><I><FONT SIZE=2 FACE="Courier">ppRegistryDict</FONT></I></TT>should be a pointer to an IMoaDict. The interface returned canbe used to add custom information to the registry entry, suchas any key/value combinations specified for a particular interface.If you don't need the registry dictionary, pass NULL. <BR><BR><B>Note: </B>Do not call <TT><FONT SIZE=2 FACE="Courier">Release()</FONT></TT>on <TT><I><FONT SIZE=2 FACE="Courier">ppRegistryDict</FONT></I></TT>.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="CreateNewInstanceFromRegistry">CreateNewInstanceFromRegistry()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>CreateNewInstanceFromRegistry(PIMoaCache<I>This</I>, <DD><BR>PIMoaRegistryEntryDict<I>pRegistryDict</I>, <BR>ConstPMoaInterfaceID<I>pInterfaceID</I>, <BR>PPMoaVoid<I>ppvObj</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></I></CODE><DD><CODE>PIMoaRegistryEntryDict</CODE>Registry dictionary forthe class/interface to instantiate <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></I></CODE><DD><CODE>ConstPMoaInterfaceID</CODE>Interface to return in ppvObj<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">ppvObj</FONT></I></CODE><DD><CODE>PPMoaVoid</CODE>Pointer to returned interface <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR><B>Note: </B>This method is intended more for use in MOA applicationcode than in Xtra code. MOA applications generally determine whenand how to create instances of specific Xtra classes and interfaces.<BR><BR>Create an instance of the class and interface cached in the dictionary<TT><I><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></I></TT>and return it in <TT><I><FONT SIZE=2 FACE="Courier">ppvObj</FONT></I></TT>.If <TT><I><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></I></TT>is not <TT><FONT SIZE=2 FACE="Courier">NULL</FONT></TT>, thatinterface will be the one returned in <TT><I><FONT SIZE=2 FACE="Courier">ppvObj</FONT></I></TT>;if the class doesn't support that interface, an error is returned.If <TT><I><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></I></TT>is <TT><FONT SIZE=2 FACE="Courier">NULL</FONT></TT>, the interfacereturned is the one specified in the <TT><I><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></I></TT>.<BR><BR>The interface returned belongs to the caller, who must call <TT><FONT SIZE=2 FACE="Courier">Release()</FONT></TT>on it when done.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="EnumerateFileEntries">EnumerateFileEntries()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>EnumerateFileEntries(PIMoaCache<I>This</I>, <DD><BR>MoaCacheFileEntryEnumProc<I>pEnumProc</I>, <BR>PMoaVoid<I>refCon</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></CODE><DD><CODE>MoaCacheFileEntryEnumProc</CODE>File enumeration function<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Pointer to structure for collecting fileinformation <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description<BR><BR></font></h4><P>Enumerates all files cached by the application. The cache coversboth the application-specific and general Xtras folders, and includesboth Xtras and other files found there. The enumeration functionyou pass in as <TT><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></TT>should have the following syntax:<BR><PRE><FONT SIZE=2>        typedef MoaError (*MoaCacheFileEntryEnumProc)(                PIMoaFileEntryDict pFileDict,                 ConstPMoaSystemFileSpec pFileSpec,                 MoaWide fileDate,                 MoaUlong fileType,      /* Mac OS type */                PMoaVoid refCon);         </FONT></PRE><DL><DT><DD>Your enumeration function will be called repeatedly for eachfile in the cache. The parameters passed to your function includethe file spec, file modification date, and file type (meaningfulonly on Macintosh systems). The <TT><I><FONT SIZE=2 FACE="Courier">pFileSpec</FONT></I></TT>passed is system dependent: it is an <TT><FONT SIZE=2 FACE="Courier">FSSpec</FONT></TT>on the Macintosh and a character string for a pathname on Windows.The <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>passed when you called <TT><FONT SIZE=2 FACE="Courier">EnumerateFileEntries()</FONT></TT>is in turn passed to your enumeration function. You can use <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>to pass a structure pointer into your enumeration function forcollecting information about files of interest; if you don't needthis pointer, pass NULL . Returning a nonzero value from yourenumeration function will terminate the enumeration.<BR><BR>Important note: the <TT><I><FONT SIZE=2 FACE="Courier">pFileSpec</FONT></I></TT>passed to you may be NULL.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="EnumerateRegistryEntries">EnumerateRegistryEntries()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>EnumerateRegistryEntries(PIMoaCache<I>This</I>, <DD><BR>MoaCacheRegistryEntryEnumProc<I>pEnumProc</I>, <BR>PMoaVoid<I>refCon</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></CODE><DD><CODE>MoaCacheRegistryEntryEnumProc</CODE>Registry dictionaryenumeration function <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Pointer to structure for collecting fileinformation <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description<BR><BR></font></h4><P>Call this method to enumerate all registry dictionaries in thecache. The cache contains one registry dictionary for each class/interfaceprovided by Xtras. The enumeration function you pass in as <TT><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></TT>should have the following syntax:<BR><PRE><FONT SIZE=2>        typedef MoaError (*MoaCacheRegistryEntryEnumProc)(                PIMoaRegistryEntryDict pRegistryDict,                 ConstPMoaClassID pClassID,                 ConstPMoaInterfaceID pInterfaceID,                 PMoaVoid refCon);         </FONT></PRE><DL><DT><DD>Your procedure will be repeatedly called for each registryin the cache. <TT><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></TT>provides the registry dictionary for the class/interface combination.<TT><FONT SIZE=2 FACE="Courier">pClassID</FONT></TT> and <TT><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></TT>provide the class and interface ID of the registered ability.You can use the class/interface pair to create the object. Itis generally more convenient to use the <TT><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></TT>and <TT><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></TT> parametersto call the <TT><FONT SIZE=2 FACE="Courier">IMoaCache</FONT></TT>methods <TT><FONT SIZE=2 FACE="Courier">GetInstanceFromRegistry()or CreateInstanceFromRegistry()</FONT></TT> to instantiate theparticular object and interface.<BR><BR>The <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>passed when you called <TT><FONT SIZE=2 FACE="Courier">EnumerateRegistryEntries()</FONT></TT>is in turn passed to your enumeration function. You can use <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>to pass a structure pointer into your enumeration function forcollecting information about classes and interface of interest;if you don't need this pointer, pass NULL . Returning a nonzerovalue from your enumeration function will terminate the enumeration.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="EnumerateRegistryEntriesFromFile">EnumerateRegistryEntriesFromFile()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>EnumerateRegistryEntriesFromFile(PIMoaCache<I>This</I>, <DD><BR>ConstPMoaSystemFileSpec<I>pFileSpec</I>, <BR>MoaLong<I>maxFolderLevels</I>, <BR>MoaCacheRegistryEntryEnumFromFileProc<I>pEnumProc</I>, <BR>PMoaVoid<I>refCon</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pFileSpec</FONT></I></CODE><DD><CODE>ConstPMoaSystemFileSpec</CODE>FSSpec on Mac/pathnamestring in Windows <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">maxFolderLevels</FONT></I></CODE><DD><CODE>MoaLong</CODE>Search depth <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></CODE><DD><CODE>MoaCacheRegistryEntryEnumFromFileProc</CODE>Registrydictionary enumeration function <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Pointer to structure for collecting registryinformation <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description<BR><BR></font></h4><P>Similar to the <TT><FONT SIZE=2 FACE="Courier">EnumerateRegistryEntries()</FONT></TT>method, this method enumerates all registry entries for a specificfolder or file. Additional information provided by the enumerationfunction includes the file and Xtra each came from. The enumerationfunction you pass in as <TT><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></TT>should have the following syntax:<BR><PRE><FONT SIZE=2>        typedef MoaError (*MoaCacheRegistryEntryEnumFromFileProc)(                PIMoaFileEntryDict pFileDict,                 ConstPMoaSystemFileSpec pFileSpec,                 MoaWide fileDate,                 MoaUlong fileType,      /* Mac OS type */                PIMoaXtraEntryDict pXtraDict,                 PIMoaRegistryEntryDict pRegistryDict,                 ConstPMoaClassID pClassID,                 ConstPMoaInterfaceID pInterfaceID,                 PMoaVoid refCon);         </FONT></PRE><DL><DT><DD><TT><I><FONT SIZE=2 FACE="Courier">pFileSpec</FONT></I></TT>returned by the enumeration function might be NULL.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="EnumerateXtraEntries">EnumerateXtraEntries()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>EnumerateXtraEntries(PIMoaCache<I>This</I>, <DD><BR>MoaCacheXtraEntryEnumProc<I>pEnumProc</I>, <BR>PMoaVoid<I>refCon</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></CODE><DD><CODE>MoaCacheXtraEntryEnumProc</CODE>Xtra dictionary enumerationfunction <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Pointer to structure for collecting Xtrainformation <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description<BR><BR></font></h4><P>Call this function to enumerate all Xtra dictionaries in the cache.The enumeration function you pass in as <TT><I><FONT SIZE=2 FACE="Courier">pEnumProc</FONT></I></TT>should have the following syntax:<BR><PRE><FONT SIZE=2>        typedef MoaError (*MoaCacheXtraEntryEnumProc)(                PIMoaXtraEntryDict pXtraDict,                 PMoaVoid refCon);         </FONT></PRE><DL><DT><DD>Your enumeration function will be called repeatedly for eachXtra in the cache. The parameters passed to your function includethe IMoaDict interface to the dictionary for each Xtra. The <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>passed when you called <TT><FONT SIZE=2 FACE="Courier">EnumerateXtraEntries()</FONT></TT>is in turn passed to your enumeration function. You can use <TT><I><FONT SIZE=2 FACE="Courier">refCon</FONT></I></TT>to pass a structure pointer into your enumeration function forcollecting information about Xtras of interest; if you don't needthis pointer, pass NULL . Returning a nonzero value from yourenumeration function will terminate the enumeration.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="GetFileSpecFromFileDict">GetFileSpecFromFileDict()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>GetFileSpecFromFileDict(PIMoaCache<I>This</I>, <DD><BR>PIMoaFileEntryDict<I>pFileDict</I>, <BR>PMoaSystemFileSpec<I>pFileSpec</I>, <BR>MoaLong<I>fileSpecLen</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pFileDict</FONT></I></CODE><DD><CODE>PIMoaFileEntryDict</CODE><TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>interface for a particular file entry <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pFileSpec</FONT></I></CODE><DD><CODE>PMoaSystemFileSpec</CODE>Returned file spec <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">fileSpecLen</FONT></I></CODE><DD><CODE>MoaLong</CODE>Length of returned file spec <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Given a file dictionary <TT><I><FONT SIZE=2 FACE="Courier">pFileDict</FONT></I></TT>,from either <TT><FONT SIZE=2 FACE="Courier">EnumerateFileEntries()</FONT></TT>or <TT><FONT SIZE=2 FACE="Courier">EnumerateRegistryEntriesFromFile()</FONT></TT>,<TT><FONT SIZE=2 FACE="Courier">GetFileSpecFromFileDict() </FONT></TT>returnsthe <TT><FONT SIZE=2 FACE="Courier">MoaSystemFileSpec</FONT></TT>associated with it. <BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="GetInstanceFromRegistry">GetInstanceFromRegistry()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>GetInstanceFromRegistry(PIMoaCache<I>This</I>, <DD><BR>PIMoaRegistryEntryDict<I>pRegistryDict</I>, <BR>ConstPMoaInterfaceID<I>pInterfaceID</I>, <BR>PPMoaVoid<I>ppvObj</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pRegistryDict</FONT></I></CODE><DD><CODE>PIMoaRegistryEntryDict</CODE>Registry dictionary forthe class/interface to instantiate <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pInterfaceID</FONT></I></CODE><DD><CODE>ConstPMoaInterfaceID</CODE>Interface to return in ppvObj<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">ppvObj</FONT></I></CODE><DD><CODE>PPMoaVoid</CODE>Pointer to returned interface <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR><B>Note:</B> This method is intended more for use in MOA applicationcode than in Xtra code. MOA applications generally determine whenand how to create instances of specific Xtra classes and interfaces.<BR><BR>Similar to <TT><FONT SIZE=2 FACE="Courier">CreateNewInstanceFromRegistry()</FONT></TT>,this method only creates a new instance of a particular classand interface the first time it is called. Subsequent calls returna new interface (via <TT><FONT SIZE=2 FACE="Courier">QueryInterface()</FONT></TT>)of the same object. The underlying object lives until MOA is shutdown (it's kept in an internal table to MOA).<BR><BR>Note that although the object remains in existence, the interfacereturned belongs to the caller, who still must call <TT><FONT SIZE=2 FACE="Courier">Release()</FONT></TT>it when done.<BR><BR></DL><P><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="SetXtraEntryNoncacheable">SetXtraEntryNoncacheable()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>SetXtraEntryNoncacheable(PIMoaCache<I>This</I>, <DD><BR>PIMoaXtraEntryDict<I>pXtraDict</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaCache</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pXtraDict</FONT></I></CODE><DD><CODE>PIMoaXtraEntryDict</CODE><TT><FONT SIZE=2 FACE="Courier">IMoaDict</FONT></TT>interface passed to Register() method <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR>Use this method to set the specified Xtra as non-cacheable. Thismethod is provided for use by certain types of Xtras that needto be able to participate in registration each time MOA is started.One such Xtra would be an adapter for non-MOA extensions thatneeds to check the presence of specific extension file types andcache them independently. <BR><BR>When you call <TT><FONT SIZE=2 FACE="Courier">SetXtraEntryNoncacheable()</FONT></TT>inside an Xtra's <TT><FONT SIZE=2 FACE="Courier">Register()</FONT></TT>method implementation, your Xtra will be registered every timea MOA application is started. The information provided by <TT><FONT SIZE=2 FACE="Courier">Register()</FONT></TT>is analyzed for the current runtime but is never stored in thecache. In general, you shouldn't make an Xtra non-cacheable, sinceit delays MOA start-up time (and thus app launch time). <BR><BR></DL><P><hr width=45% align=left><P><A HREF="../copyrite.htm" >Copyright &#169; 1995, 1996, 1997, 1998, 1999 Macromedia, Inc.</A></BODY><!--#include virtual="/uber/html/footer.html" --></html>