<HTML><HEAD><TITLE>IMoaStream</TITLE></HEAD><body bgcolor="#FFFFFF"  link="#ff3300" alink="#ff3300" vlink="#333399"><A HREF="../moadg/index.htm">MOA Developer's Guide</A><BR><A HREF="index.htm">MOA Interfaces</A> | <A HREF="momthndx.htm">MOA Methods</A> | <A HREF="motypndx.htm">MOA Types and Misc API</A><hr width=45% align=left><h2><font face=arial,helvetica,sans-serif>IMoaStream</font></h2><hr width=45% align=left><P>Interface ID: <CODE>IID_IMoaStream<BR></CODE>Pointer type: <CODE>PIMoaStream<BR></CODE>Inheritance: <A HREF = "unknown.htm"><FONT SIZE=2>IMoaUnknown</FONT></A><BR>Header file: <A HREF = "../../include/moastdif.h">moastdif.h</A><BR><h3><font face=arial,helvetica,sans-serif>Description</font></h3><DL><DT><DD><BR>The <TT><FONT SIZE=2 FACE="Courier">IMoaStream</FONT></TT> interfaceis designed as a universal interface for streaming data to allMOA-enabled documents. This interface may be implemented for accessingdata in a disk file, memory structure, internet site, etc. The<TT><FONT SIZE=2 FACE="Courier">IMoaStream</FONT></TT> interfaceis designed to totally encapsulate the nature of the data beingread or written. It provides techniques for random access of thedata, though specific implementations may not enable these randomaccess techniques.<BR><BR>Note: Specific providers of this interface may include certainimplementation details worth noting. These distinctions are documentedwith the XDK for a specific implementation. <BR><BR></DL><h3><font face=arial,helvetica,sans-serif>See also</font></h3><DL><DT><DD><A href="motypndx.htm#MOSTRMTYPE">IMoaStream types</A>, <A href="motypndx.htm#MOSTRMCONST">IMoaStream constants</A>, <A href="motypndx.htm#MOSTRMERRS">IMoaStream errors</A></DL><h3><font face=arial,helvetica,sans-serif>Methods</font></h3><DL><DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Opening and closing </font></h4><DL><DT><DD><A HREF = "#Open">Open()</A> <BR><A HREF = "#Close">Close()</A> </DL><h4><font face=arial,helvetica,sans-serif>Accessing data </font></h4><DL><DT><DD><A HREF = "#Read">Read()</A> <BR><A HREF = "#ReadAhead">ReadAhead()</A> </DL><h4><font face=arial,helvetica,sans-serif>Writing data </font></h4><DL><DT><DD><A HREF = "#Write">Write()</A> <BR><A HREF = "#Flush">Flush()</A> </DL><h4><font face=arial,helvetica,sans-serif>Positioning </font></h4><DL><DT><DD><A HREF = "#GetPosition">GetPosition()</A> <BR><A HREF = "#SetPosition">SetPosition()</A> <BR><A HREF = "#GetEnd">GetEnd()</A> </DL><h4><font face=arial,helvetica,sans-serif>Determining capabilities </font></h4><DL><DT><DD><A HREF = "#GetModes">GetModes()</A> </DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="Close">Close()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>Close(PIMoaStream<I>This</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Call this method when through using the stream. It does notnecessarily flush the stream; you should explicitly call <TT><FONT SIZE=2 FACE="Courier">Flush()</FONT></TT>toforce a write of all data. <BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="Flush">Flush()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>Flush(PIMoaStream<I>This</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Flushes any buffered data stored in the stream. Call thisto ensure that data written to the stream is passed all the waythrough. <BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="GetEnd">GetEnd()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>GetEnd(PIMoaStream<I>This</I>, <DD><BR>MoaStreamPosition FAR *<I>pPos</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pPos</FONT></I></CODE><DD><CODE>MoaStreamPosition FAR *</CODE>Offset of the end of thedata <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>The <TT><FONT SIZE=2 FACE="Courier">GetEnd()</FONT></TT> methodgets the position of the current end-of-stream. Attempting toread past this position will fail. Attempting to write past thisposition may or may not succeed, depending on the nature of themedia. Streams opened with <TT><FONT SIZE=2 FACE="Courier">kMoaStreamSetPositionType_None</FONT></TT>may return <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_NoSetPosition</FONT></TT>.<BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="GetModes">GetModes()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>GetModes(PIMoaStream<I>This</I>, <DD><BR>MoaLong FAR *<I>pAccessMode</I>, <BR>MoaLong FAR *<I>pSetPositionType</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pAccessMode</FONT></I></CODE><DD><CODE>MoaLong FAR *</CODE>Returns the access mode <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pSetPositionType</FONT></I></CODE><DD><CODE>MoaLong FAR *</CODE>Returns the seek type <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Call this method to get the access mode (in <TT><I><FONT SIZE=2 FACE="Courier">pAccessMode</FONT></I></TT>)and seek mode (in <TT><I><FONT SIZE=2 FACE="Courier">pSetPositionType</FONT></I></TT>)that were specified when <TT><FONT SIZE=2 FACE="Courier">Open()</FONT></TT>was called on the <TT><FONT SIZE=2 FACE="Courier">IMoaStream <I>This</I></FONT></TT>.<BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="GetPosition">GetPosition()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>GetPosition(PIMoaStream<I>This</I>, <DD><BR>MoaStreamPosition FAR *<I>pPos</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pPos</FONT></I></CODE><DD><CODE>MoaStreamPosition FAR *</CODE>Returns current position<BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Call this method to acquire, in <TT><I><FONT SIZE=2 FACE="Courier">pPos</FONT></I></TT>,the current position in the stream from which reads or writeswill take place. Note that this is a 32-bit unsigned integer thatis always an absolute offset from the start of the stream. <BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="Open">Open()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>Open(PIMoaStream<I>This</I>, <DD><BR>MoaLong<I>accessMode</I>, <BR>MoaLong<I>setPositionType</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">accessMode</FONT></I></CODE><DD><CODE>MoaLong</CODE>Constant specifying the access mode <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">setPositionType</FONT></I></CODE><DD><CODE>MoaLong</CODE>Constant specifying the seek type <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR>The <TT><FONT SIZE=2 FACE="Courier">Open()</FONT></TT> methodopens the stream for reading or writing. You must open the streambefore calling other methods on it. The parameter <TT><I><FONT SIZE=2 FACE="Courier">pAccessMode</FONT></I></TT>specifies the access mode (read, write, or read/write). Use oneof the access mode constants described below for this parameter.<BR><BR>The <TT><I><FONT SIZE=2 FACE="Courier">pSetPositionType</FONT></I></TT>parameter specifies the seekability provided by <TT><FONT SIZE=2 FACE="Courier">SetPosition()</FONT></TT>.Use one of the set position constants described below for thisparameter. Providing the appropriate constant enables the streamto optimize for particular seeking needs. However, not all streamssupport all seekability modes. More specifically, a stream maynot support seeking at all, or may support only &quot;expensive&quot;seeking. If you specify an unavailable seek mode, Open() returnsan error. <BR><BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="Read">Read()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>Read(PIMoaStream<I>This</I>, <DD><BR>PMoaVoid<I>pBuf</I>, <BR>MoaStreamCount<I>numToRead</I>, <BR>MoaStreamCount FAR *<I>pNumActuallyRead</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pBuf</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Buffer to read data into <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">numToRead</FONT></I></CODE><DD><CODE>MoaStreamCount</CODE>Data size requested <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></CODE><DD><CODE>MoaStreamCount FAR *</CODE>Data size delivered <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD><BR>Call this method to read data from the stream. This method hasslightly different semantics depending on the <TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></TT>parameter:<BR><BR>If you pass NULL for <TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></TT>,then <TT><FONT SIZE=2 FACE="Courier">Read()</FONT></TT> attemptsto read exactly <TT><FONT SIZE=2 FACE="Courier">numToRead</FONT></TT>bytes from the current position in the stream and copy them intothe buffer. If there aren't enough bytes remaining (i.e., youread past the end), <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_ReadPastEnd</FONT></TT>is returned (whether or not data is copied into the buffer isundefined).<BR><BR>If you pass a value for <TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></TT>,then <TT><FONT SIZE=2 FACE="Courier">Read()</FONT></TT> will readas much as can be read &quot;quickly&quot;, perhaps returning<TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></TT>&lt; <TT><I><FONT SIZE=2 FACE="Courier">numToRead</FONT></I></TT>without an error indication. Reading past the end of the streamwill return <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_ReadPastEnd</FONT></TT>with <TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></TT>set correctly. Note that &quot;quickly&quot; is implementation-defined.<BR><BR>In all cases, if the return value is <TT><FONT SIZE=2 FACE="Courier">kMoaErr_NoErr</FONT></TT>or <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_ReadPastEnd</FONT></TT>,the stream position is set to the first byte past the data read;otherwise, the stream position is unchanged. <BR><BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="ReadAhead">ReadAhead()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>ReadAhead(PIMoaStream<I>This</I>, <DD><BR>PMoaVoid<I>pBuf</I>, <BR>MoaStreamCount<I>numToRead</I>, <BR>MoaStreamCount FAR *<I>pNumActuallyRead</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pBuf</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Buffer to read data into <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">numToRead</FONT></I></CODE><DD><CODE>MoaStreamCount</CODE>Data size requested <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pNumActuallyRead</FONT></I></CODE><DD><CODE>MoaStreamCount FAR *</CODE>Data size delivered <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>This method is similar to <TT><FONT SIZE=2 FACE="Courier">Read()</FONT></TT>,except that the stream position is never advanced, even if theread is successful. This call is particularly useful with non-seek(or expensive-seek) streams. Note that you are only guaranteedto be able to read amounts of <TT><FONT SIZE=2 FACE="Courier">kMoaStreamReadAheadLimit</FONT></TT>or less (defined as 32); some streams may allow more, but it isnot guaranteed. If you ask for more than the stream supports,it will return <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_ReadAheadTooFar</FONT></TT>.<BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="SetPosition">SetPosition()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>SetPosition(PIMoaStream<I>This</I>, <DD><BR>MoaStreamPosition<I>pos</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pos</FONT></I></CODE><DD><CODE>MoaStreamPosition</CODE>New position requested <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Call this method to set the position in the stream from whichsubsequent reads or writes will begin. The <TT><I><FONT SIZE=2 FACE="Courier">pos</FONT></I></TT>specified is a 32-bit unsigned integer that is always an absoluteoffset from the start of the stream. Note: it is legal to setthe position outside the end of the stream; however, an attemptto read from such a position will return an error. Note: streamsopened with <TT><FONT SIZE=2 FACE="Courier">kMoaStreamSetPositionType_None</FONT></TT>will always return <TT><FONT SIZE=2 FACE="Courier">kMoaStreamErr_NoSetPosition</FONT></TT>.<BR></DL><hr width=45% align=left><h3><font face=arial,helvetica,sans-serif><A NAME="Write">Write()</A></font></h3><h4><font face=arial,helvetica,sans-serif>Syntax</font></h4><DL><DT><DD><DT>Write(PIMoaStream<I>This</I>, <DD><BR>PMoaVoid<I>pBuf</I>, <BR>MoaStreamCount<I>numToWrite</I>, <BR>MoaStreamCount FAR *<I>pNumActuallyWritten</I>)<DT><DD></DL><h4><font face=arial,helvetica,sans-serif>Parameters</font></h4><DL><DT><DD><DT><CODE><I><FONT SIZE=2 FACE="Courier">This</FONT></I></CODE><DD>Pointer to the <CODE>IMoaStream</CODE> interface<BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pBuf</FONT></I></CODE><DD><CODE>PMoaVoid</CODE>Buffer to write data from <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">numToWrite</FONT></I></CODE><DD><CODE>MoaStreamCount</CODE>Data size to be delivered <BR><BR><DT><CODE><I><FONT SIZE=2 FACE="Courier">pNumActuallyWritten</FONT></I></CODE><DD><CODE>MoaStreamCount FAR *</CODE>Data size delivered <BR><BR></DL><h4><font face=arial,helvetica,sans-serif>Returns</font></h4><DL><DT><DD><CODE>MoaError</CODE></DL><h4><font face=arial,helvetica,sans-serif>Description</font></h4><DL><DT><DD>Call this method to write data to the stream <TT><I><FONT SIZE=2 FACE="Courier">This</FONT></I></TT>.This method attempts to write <TT><I><FONT SIZE=2 FACE="Courier">numToWrite</FONT></I></TT>bytes to the current position in the stream and advances the streamposition by that number of bytes. An attempt to write past theend of the stream extends the stream length before writing (ifpossible). If the write is successful, the stream position isset to the first byte past the data written. If the write is unsuccessful,the stream position is unchanged. If <TT><I><FONT SIZE=2 FACE="Courier">pNumActuallyWritten</FONT></I></TT>is not NULL, it will be set to the number of bytes actually written.<BR><BR></DL><hr width=45% align=left><P><A HREF="../copyrite.htm">Copyright &#169; 1995, 1996, 1997, 1998, 1999 Macromedia, Inc.</A></BODY><!--#include virtual="/uber/html/footer.html" --></html>